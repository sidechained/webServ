Aim: 

Use CGI and php to handle file uploads via a html form

Steps:

1. In our browser on the client side, we upload a file via a web form (form.html), which sends a POST request (postRequest.txt)

The post request has a Content-Type of 'multipart/form-data' meaning other types can be contained as 'parts' within the body

2. Our server recieves the POST request and parses it

It populates these structs:

struct PostUploadRequest {
	std::string method;
	std::string resource;
	std::string httpVersion;
	std::map<std::string, std::string> headers;
	std::vector<Part> parts;
};

struct Part {
	std::map<std::string, std::string> headers;
	ContentDisposition contentDisposition;
	std::string data;
};

struct ContentDisposition {
	std::string type;
	std::string name;
	std::string filename;
};

And extracts the data from each parts into a single file and puts them in a temporary location ('/tmp/output.txt')

3. We now perform some basic validity checks based on the struct and our config

a. Does our config file allows POST requests for this route/location (config.location("key").methods)?
- if not then return "405 Method Not Allowed"

b. Does our request meet the following conditions?
	- is it a POST request (postRequest.method)
	- is the file extension of the resource '.php' (extract file extensions from postRequest.resource)
	if NO then it's not relevant to cgi/php and we continue down our request checks (Luca/Marco's code)
	if YES then:
	- check is the client body size < max allowed client body size?
	if NO then server should return a "413 Payload Too Large" and go no further
	if YES continue

4. Prepare the CGI environment in order to successfully run our 'upload.php' script

We need to pass our php script four variables:

```
$_SERVER["REQUEST_METHOD"]
$_FILES["fileToUpload"]["error"]
$_FILES["fileToUpload"]["name"]
$_FILES["fileToUpload"]["tmp_name"]
```

In PHP, variables beginning with an underscore such as `$_SERVER` or `$_FILES` are superglobals i.e. an arrays of environment variables.

The `$_SERVER` superglobal will just be a copy of our current environment, which we can add to using setenv() or putenv()

I don't know yet how `$_FILES` is setup, more research is needed

Also, $uploadDir will also eventually be needed (it's hardcoded as '/upload' for now)

5. Fork and execve the 'upload.php' script

As long as the request is a POST request and the file exists, our php script will simply move the temporary data file generated by our PostUploadRequestParser into it's correct location ('/upload') and then report whether it was successful or not

At the moment it just prints feedback, but it should also return a SUCCESS or FAILURE exit status

6. Get the exit status of the php script and act accordingly

The http response generation will be done by our server, as we are already generating other responses Luca/Marco's code

- if EXIT_SUCCESS return "200 OK" with "file uploaded successfully" in body
- if EXIT_FAILURE return "500 Internal Server Error"